import { test } from "@cross/test";
import { assert } from "@std/assert";
import { buildDependencyGraph, generate, refToTypeName } from "../src/codegen.ts";
import type { ResolvedSchemaMap, SchemaObject } from "../mod.ts";

test("codegen produces interface for object schema", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        const schema: SchemaObject = {
            type: "object",
            properties: {
                id: { type: "integer" },
                user_name: { type: "string" },
            },
            required: ["id"],
        };
        map.set("User", schema);
        const out = generate(map, { propertyNaming: "camel" });
        assert(out.includes("export interface User"));
        assert(out.includes("id: number"));
        assert(out.includes("userName?: string"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen preserves property names when option preserve", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("X", {
            type: "object",
            properties: { foo_bar: { type: "string" } },
            required: [],
        });
        const out = generate(map, { propertyNaming: "preserve" });
        assert(out.includes("foo_bar"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen enum becomes union", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("Status", { type: "string", enum: ["active", "inactive"] });
        const out = generate(map, {});
        assert(out.includes('"active"'));
        assert(out.includes('"inactive"'));
        assert(out.includes(" | "));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen uses tab indent when indent.useTabs is true", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("User", {
            type: "object",
            properties: { name: { type: "string" } },
            required: ["name"],
        });
        const out = generate(map, { indent: { useTabs: true } });
        assert(out.includes("\tname: string"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen uses custom space width for indent", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("User", {
            type: "object",
            properties: { name: { type: "string" } },
            required: ["name"],
        });
        const out = generate(map, { indent: { useTabs: false, width: 2 } });
        assert(out.includes("  name: string"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen omit header when includeHeader is false", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("X", { type: "object", properties: {}, required: [] });
        const out = generate(map, { includeHeader: false });
        assert(!out.includes("Auto-generated"));
        assert(!out.includes("DO NOT EDIT"));
        assert(out.includes("export type X = Record<string, unknown>"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen uses custom headerComment when provided", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("X", { type: "object", properties: {}, required: [] });
        const custom = "// Generated from my-api.yaml - do not edit";
        const out = generate(map, { headerComment: custom });
        assert(out.startsWith(custom));
        assert(!out.includes("Auto-generated TypeScript types"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen default header includes tool, generated-at, and optional sourceLabel", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("X", { type: "object", properties: {}, required: [] });
        const out = generate(map, { sourceLabel: "https://api.example.com/openapi.json" });
        assert(out.includes("@pinta365/openapi-typegen"));
        assert(out.includes("Generated at:"));
        assert(out.includes("Source file: https://api.example.com/openapi.json"));
        assert(out.includes("DO NOT EDIT THIS FILE MANUALLY"));
        done();
    } catch (e) {
        done(e);
    }
});

test("buildDependencyGraph collects refs from schema", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("A", { type: "object", properties: { b: { $ref: "#/components/schemas/B" } }, required: [] });
        map.set("B", { type: "object", properties: {}, required: [] });
        const graph = buildDependencyGraph(map);
        assert(graph.get("A")?.has("B"));
        assert(!graph.get("B")?.has("A"));
        done();
    } catch (e) {
        done(e);
    }
});

test("refToTypeName converts kebab-case schema names to valid PascalCase identifiers", (_context, done) => {
    try {
        const name = refToTypeName("#/components/schemas/security-advisory-ecosystems");
        assert(name === "SecurityAdvisoryEcosystems");
        assert(!name.includes("-"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen adds Format to type JSDoc when schema has format", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("Timestamp", { type: "string", format: "date-time" });
        const out = generate(map, {});
        assert(out.includes("Format: date-time"));
        assert(out.includes("Timestamp"));
        done();
    } catch (e) {
        done(e);
    }
});

test("codegen adds Format to property JSDoc when property schema has format", (_context, done) => {
    try {
        const map: ResolvedSchemaMap = new Map();
        map.set("User", {
            type: "object",
            properties: { email: { type: "string", format: "email" } },
            required: [],
        });
        const out = generate(map, {});
        assert(out.includes("Format: email"));
        assert(out.includes("email"));
        done();
    } catch (e) {
        done(e);
    }
});
